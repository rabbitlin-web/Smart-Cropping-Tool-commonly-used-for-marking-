<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RabbitLin Smart Slicer - AI Training Data Tool / åœ¨çº¿æ™ºèƒ½åˆ‡å›¾å·¥å…·(V30 æ¨¡æ‹Ÿäººå·¥ç‰ˆ)</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/buzzfeed/libgif-js@master/libgif.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    
    <style>
        :root { --primary: #ffcc00; --bg: #121212; --panel: #1e1e1e; --text: #e0e0e0; --accent: #2d2d2d; --wechat: #09bb07; --border: #444; }
        body { font-family: 'Segoe UI', Roboto, "Microsoft YaHei", sans-serif; background: var(--bg); color: var(--text); display: flex; flex-direction: column; align-items: center; padding: 20px; min-height: 100vh; }
        .container { background: var(--panel); padding: 30px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.6); width: 1100px; max-width: 98%; margin-bottom: 40px; position: relative; }
        
        h1 { color: #fff; margin: 0; text-align: center; font-size: 26px; font-weight: 600; margin-bottom: 10px; }
        h1 span { color: var(--primary); font-size: 22px; }
        .subtitle { text-align: center; color: #888; font-size: 14px; margin-bottom: 20px; }

        /* Social Bar */
        .social-bar { display: flex; justify-content: center; gap: 15px; margin-bottom: 25px; flex-wrap: wrap; }
        .social-btn { display: flex; align-items: center; gap: 8px; padding: 8px 16px; border-radius: 50px; text-decoration: none; font-size: 13px; font-weight: bold; transition: transform 0.2s; cursor: pointer; border: none; }
        .social-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
        .btn-github { background: #333; color: #fff; border: 1px solid #555; }
        .btn-github span { color: var(--primary); }
        .btn-wechat { background: var(--wechat); color: #fff; }

        /* Tutorial Steps */
        .tutorial-steps { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-bottom: 25px; background: #222; padding: 20px; border-radius: 8px; border: 1px solid #333; }
        .step-item { display: flex; align-items: flex-start; gap: 10px; }
        .step-num { background: var(--primary); color: #000; width: 24px; height: 24px; border-radius: 50%; text-align: center; font-size: 14px; font-weight: bold; line-height: 24px; flex-shrink: 0; }
        .step-text { font-size: 13px; color: #aaa; line-height: 1.5; }
        .step-text strong { color: #fff; display: block; margin-bottom: 4px; font-size: 14px; }
        .highlight { color: var(--primary); font-weight: bold; }

        /* Layout & Panels */
        .main-layout { display: flex; gap: 25px; flex-wrap: wrap; }
        .left-col { flex: 2; min-width: 320px; }
        .right-col { flex: 1; min-width: 280px; display: flex; flex-direction: column; gap: 15px; }
        .panel { background: var(--accent); padding: 20px; border-radius: 8px; margin-bottom: 15px; border: 1px solid var(--border); }
        .panel-title { font-size: 15px; font-weight: bold; color: #fff; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; }
        
        .method-label { font-size: 12px; color: #888; margin-top: 10px; margin-bottom: 5px; font-weight: bold; display: block; }
        .method-highlight { color: var(--primary); }

        /* Inputs */
        .control-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        label { font-size: 12px; color: #aaa; margin-bottom: 4px; display: block; font-weight: bold; }
        input[type="number"], select { width: 100%; padding: 8px; background: #333; border: 1px solid #555; color: #fff; border-radius: 4px; font-weight: bold; font-size: 13px; box-sizing: border-box; }
        input[type="number"]:focus, select:focus { border-color: var(--primary); outline: none; }
        .slider-group { margin-bottom: 15px; }
        input[type=range] { width: 100%; accent-color: var(--primary); margin-top: 5px; }
        .range-value { float: right; color: var(--primary); font-weight: bold; }

        /* Upload & Button */
        .upload-area { text-align: center; border: 2px dashed #555; padding: 20px; border-radius: 8px; cursor: pointer; transition: 0.2s; background: #222; margin-bottom: 20px; }
        .upload-area:hover { border-color: var(--primary); background: #2a2a2a; }
        .main-btn { width: 100%; padding: 16px; background: linear-gradient(135deg, #ffcc00 0%, #ffaa00 100%); color: #000; border: none; border-radius: 6px; font-weight: bold; font-size: 16px; cursor: pointer; transition: 0.2s; }
        .main-btn:hover { filter: brightness(1.1); }
        .main-btn:disabled { background: #444; color: #888; cursor: not-allowed; }

        /* Preview Areas */
        #canvas-container { position: relative; width: 100%; overflow: hidden; border: 2px solid #444; border-radius: 4px; background: #000; min-height: 200px; display: flex; align-items: center; justify-content: center; cursor: crosshair; }
        canvas { display: block; max-width: 100%; height: auto; }
        .single-preview-box { background: #000; border: 1px solid #555; border-radius: 4px; overflow: hidden; display: flex; align-items: center; justify-content: center; height: 200px; position: relative; }
        .single-preview-box img { max-width: 100%; max-height: 100%; object-fit: contain; }
        
        .new-tag { background: #ff0055; color: #fff; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 8px; vertical-align: middle; }

        /* Progress & Warnings */
        #progress-section { display: none; margin-top: 15px; background: #222; padding: 15px; border-radius: 6px; border: 1px solid #444; }
        #progress-bar-bg { width: 100%; height: 10px; background: #444; border-radius: 5px; overflow: hidden; margin: 10px 0; }
        #progress-fill { width: 0%; height: 100%; background: var(--primary); transition: width 0.2s; }
        #status-text { color: #fff; font-size: 13px; text-align: center; font-weight: bold; }
        #debug-log { color: #ff5555; font-size: 11px; font-family: monospace; margin-top: 5px; text-align: center; min-height: 15px; }
        .win-warning { margin-top: 15px; padding: 12px; background: #441818; border: 1px solid #883333; border-radius: 6px; text-align: center; color: #ff8888; font-size: 13px; line-height: 1.5; }

        /* Hidden GIF Source - CRITICAL CHANGE: Must be visible but tiny for libgif to work in batch */
        #gif-source-container { position: absolute; top: 0; left: 0; width: 1px; height: 1px; opacity: 0.01; overflow: hidden; pointer-events: none; }

        .footer { margin-top: auto; padding-top: 20px; text-align: center; color: #666; font-size: 13px; border-top: 1px solid #333; width: 100%; }
        .author-tag { color: var(--primary); font-weight: bold; }
        
        /* Modal */
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 999; justify-content: center; align-items: center; backdrop-filter: blur(5px); }
        .modal-box { background: #fff; padding: 20px; border-radius: 12px; text-align: center; max-width: 90%; width: 350px; position: relative; animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .modal-box img { width: 100%; border-radius: 8px; }
        .modal-close { position: absolute; top: 10px; right: 15px; font-size: 24px; color: #333; cursor: pointer; font-weight: bold; }
        .modal-text { color: #333; margin-top: 10px; font-weight: bold; font-size: 16px; }
        .modal-sub { color: #666; font-size: 13px; margin-bottom: 10px; }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    </style>
</head>
<body>

<div class="container">
    <h1>RabbitLin Smart Slicer <span>V30.0 (Visual Batch)</span></h1>
    <div class="subtitle">åœ¨çº¿æ™ºèƒ½åˆ‡å›¾å·¥å…· (æ‰“æ ‡/åŠ¨å›¾/å…¨èƒ½ç‰ˆ)</div>

    <div class="social-bar">
        <a href="https://github.com/rabbitlin-web/smart-crop-tool" target="_blank" class="social-btn btn-github">
            <svg height="16" width="16" viewBox="0 0 16 16" fill="#ffffff"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path></svg>
            Github æ±‚ Star (âœ§Ï‰âœ§)
        </a>
        <button class="social-btn btn-wechat" onclick="openModal()">
            ğŸ¥¤ æŠ•å–‚å…”å­ / Buy me a milk tea
        </button>
    </div>

    <div class="tutorial-steps">
        <div class="step-item">
            <div class="step-num">1</div>
            <div class="step-text"><strong>Upload / ä¸Šä¼ </strong>JPG, PNG, GIF supported.<br>æ‰¹é‡ä¸Šä¼ è¯·æŒ‰ä½Ctrl/Shiftã€‚</div>
        </div>
        <div class="step-item">
            <div class="step-num">2</div>
            <div class="step-text"><strong>Align / å¯¹é½ (2 Ways)</strong>
                A: <span class="highlight">Drag Yellow Handle (æ‹–æ‹½)</span><br>
                B: <span class="highlight">Input Gap Value (è¾“é—´è·)</span>
            </div>
        </div>
        <div class="step-item">
            <div class="step-num">3</div>
            <div class="step-text"><strong>Smart Fix / æ™ºèƒ½é‡æ„</strong>Use Scale & Anchor.<br>åˆ©ç”¨ç¼©æ”¾å’Œé”šç‚¹ä¿®å¤æ„å›¾ã€‚</div>
        </div>
        <div class="step-item">
            <div class="step-num">4</div>
            <div class="step-text"><strong>Export / å¯¼å‡º</strong>Download ZIP.<br>ç¡®è®¤æ— è¯¯åç‚¹å‡»ä¸‹è½½ã€‚</div>
        </div>
    </div>

    <div class="upload-area" onclick="document.getElementById('upload').click()">
        <input type="file" id="upload" accept="image/jpeg, image/png, image/webp, image/gif" multiple style="display: none;">
        <div style="font-size: 18px; margin-bottom: 5px;">ğŸ“‚ <strong>Click to Upload / ç‚¹å‡»ä¸Šä¼  (JPG/PNG/GIF)</strong></div>
        <div id="file-info" style="font-size: 13px; color: #888;">Supports Multiple Files & GIFs</div>
    </div>

    <div id="gif-source-container">
        <img id="gif-source">
    </div>

    <div class="main-layout">
        <div class="left-col">
            <div class="panel">
                <div class="panel-title">1. Grid Structure / åŸºç¡€ç»“æ„è®¾ç½®</div>
                <div class="control-grid">
                    <div><label>Columns / åˆ—æ•°</label><input type="number" id="cols" value="5" min="1"></div>
                    <div><label>Rows / è¡Œæ•°</label><input type="number" id="rows" value="3" min="1"></div>
                </div>
                
                <div style="margin-top:15px; border-top:1px dashed #444; padding-top:10px;">
                    <div class="control-grid">
                        <div>
                            <span class="method-label method-highlight">Method 1: Visual Drag (æ¨èæ‹–æ‹½)</span>
                            <label style="font-weight:normal; font-size:11px; margin-bottom:5px;">Lock Ratio / é”å®šæ‹–æ‹½æ¯”ä¾‹</label>
                            <select id="aspect-ratio">
                                <option value="free">Free Drag / è‡ªç”±æ‹–æ‹½</option>
                                <option value="1">1:1 Square / æ­£æ–¹å½¢</option>
                                <option value="1.7777777">16:9 Landscape / æ¨ªå±</option>
                                <option value="0.5625">9:16 Portrait / ç«–å±</option>
                                <option value="1.3333333">4:3 Standard</option>
                                <option value="0.75">3:4 Vertical</option>
                                <option value="1.5">3:2 Classic</option>
                                <option value="0.6666666">2:3 Vertical</option>
                            </select>
                        </div>
                        <div>
                            <span class="method-label">Method 2: Manual Input (è¾“å…¥é—´è·)</span>
                            <label style="font-weight:normal; font-size:11px; margin-bottom:5px;">Gap in Pixels / åƒç´ å€¼</label>
                            <div style="display:flex; gap:5px;">
                                <input type="number" id="gap-x" value="0" placeholder="Gap X">
                                <input type="number" id="gap-y" value="0" placeholder="Gap Y">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <div class="panel-title">2. Export Settings / å¯¼å‡ºè®¾ç½®</div>
                <div class="control-grid">
                    <div>
                        <label>Output Size / å°ºå¯¸</label>
                        <select id="resize-opt">
                            <option value="original">Original / åŸå§‹</option>
                            <option value="768x768">768x768</option>
                            <option value="1024x1024">1024x1024</option>
                            <option disabled>--- 16:9 ---</option>
                            <option value="1280x720">1280x720 (HD)</option>
                            <option value="1920x1080">1920x1080 (FHD)</option>
                            <option value="1024x576">1024x576</option>
                            <option disabled>--- 9:16 ---</option>
                            <option value="720x1280">720x1280</option>
                            <option value="1080x1920">1080x1920</option>
                            <option value="576x1024">576x1024</option>
                        </select>
                    </div>
                    <div>
                        <label>Mode / æ¨¡å¼</label>
                        <select id="resize-mode">
                            <option value="cover">Smart Crop (æ¨è! ä¸å˜å½¢)</option>
                            <option value="contain">Contain (é»‘è¾¹)</option>
                            <option value="stretch">Stretch (æ‹‰ä¼¸)</option>
                        </select>
                    </div>
                </div>
                
                <div style="margin-top:15px;">
                    <label>Zoom / ç¼©æ”¾: <span id="scale-val" style="color:var(--primary)">100%</span></label>
                    <input type="range" id="content-scale" min="50" max="150" value="100">
                    
                    <label style="margin-top:10px;">Anchor / 9ç‚¹é”šç‚¹ (9-Point)</label>
                    <select id="anchor-pos">
                        <option value="center">Center / å±…ä¸­</option>
                        <option disabled>--- Top ---</option>
                        <option value="top-left">Top Left / å·¦ä¸Š</option>
                        <option value="top-center">Top Center / é¡¶ä¸­</option>
                        <option value="top-right">Top Right / å³ä¸Š</option>
                        <option disabled>--- Middle ---</option>
                        <option value="middle-left">Middle Left / å±…å·¦</option>
                        <option value="middle-right">Middle Right / å±…å³</option>
                        <option disabled>--- Bottom ---</option>
                        <option value="bottom-left">Bottom Left / å·¦ä¸‹</option>
                        <option value="bottom-center">Bottom Center / åº•ä¸­</option>
                        <option value="bottom-right">Bottom Right / å³ä¸‹</option>
                    </select>
                </div>
            </div>
            
            <button id="processBtn" class="main-btn" disabled>âœ… Start Processing / å¼€å§‹å¤„ç†</button>
            
            <div id="progress-section">
                <div id="status-text">Ready / å°±ç»ª</div>
                <div id="progress-bar-bg"><div id="progress-fill"></div></div>
                <div id="debug-log"></div>
            </div>

            <div class="win-warning">
                âš ï¸ <strong>Windows Users:</strong> Please use 7-Zip or Bandizip to extract / <strong>Windowsç”¨æˆ·:</strong> è¯·ä½¿ç”¨ 7-Zip æˆ– Bandizip è§£å‹
            </div>
        </div>

        <div class="right-col">
            <div class="panel">
                <div class="panel-title">Preview / å•å›¾é¢„è§ˆ <span class="new-tag" id="gif-tag" style="display:none;">GIF</span></div>
                <div class="single-preview-box">
                    <img id="single-preview-img" alt="Preview">
                </div>
                <div style="text-align:center; font-size:12px; color:#666; margin-top:5px;">Target: <span id="final-res">--</span></div>
            </div>
            <div class="panel">
                <div class="panel-title">Grid / æ•´ä½“å¯¹é½</div>
                <div id="canvas-container">
                    <canvas id="previewCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="footer">
    Designed by <span class="author-tag">RabbitLin</span> | å¾®ä¿¡å·: <span class="author-tag">Aa272123071</span>
</div>

<div id="qrModal" class="modal-overlay" onclick="closeModal(event)">
    <div class="modal-box">
        <div class="modal-close" onclick="closeModalBtn()">Ã—</div>
        <div class="modal-text">ğŸ¥¤ Buy me a Milk Tea ~</div>
        <div class="modal-sub">æ—¢ç„¶å¥½ç”¨ï¼Œå°±è¯·å…”å­å–æ¯èŒ¶å§ (å¼€å¿ƒ)</div>
        <img src="pay.jpg" alt="WeChat Pay" onerror="this.src='https://via.placeholder.com/300?text=Please+Upload+pay.jpg';">
        <div style="margin-top:10px; font-size:12px; color:#999;">WeChat Pay / å¾®ä¿¡æ”¯ä»˜</div>
    </div>
</div>

<script>
    const workerBlob = new Blob([`importScripts('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js');`], { type: 'application/javascript' });
    const workerUrl = URL.createObjectURL(workerBlob);

    function openModal() { document.getElementById('qrModal').style.display = 'flex'; }
    function closeModalBtn() { document.getElementById('qrModal').style.display = 'none'; }
    function closeModal(e) { if (e.target.id === 'qrModal') closeModalBtn(); }

    const el = {
        upload: document.getElementById('upload'),
        cols: document.getElementById('cols'), rows: document.getElementById('rows'),
        gapX: document.getElementById('gap-x'), gapY: document.getElementById('gap-y'),
        aspectRatio: document.getElementById('aspect-ratio'),
        contentScale: document.getElementById('content-scale'), scaleVal: document.getElementById('scale-val'),
        anchorPos: document.getElementById('anchor-pos'), 
        resizeOpt: document.getElementById('resize-opt'), resizeMode: document.getElementById('resize-mode'),
        processBtn: document.getElementById('processBtn'), canvas: document.getElementById('previewCanvas'),
        singlePreview: document.getElementById('single-preview-img'), finalRes: document.getElementById('final-res'),
        fileInfo: document.getElementById('file-info'), gifSource: document.getElementById('gif-source'),
        gifTag: document.getElementById('gif-tag'),
        progSection: document.getElementById('progress-section'), progFill: document.getElementById('progress-fill'),
        statusText: document.getElementById('status-text'), debugLog: document.getElementById('debug-log')
    };
    const ctx = el.canvas.getContext('2d');
    
    // Batch State
    let state = { 
        files: [], currentImg: new Image(), 
        isLoaded: false, isGif: false, superGif: null,
        cellW: 0, cellH: 0, isDragging: false, dragStartPos: {x:0,y:0}, initialCellSize: {w:0,h:0}, scaleFactor: 1 
    };

    const inputs = [el.cols, el.rows, el.gapX, el.gapY, el.aspectRatio, el.contentScale, el.anchorPos, el.resizeOpt, el.resizeMode];
    inputs.forEach(input => input.addEventListener('input', () => {
        if(input === el.contentScale) el.scaleVal.innerText = el.contentScale.value + '%';
        updateCalculation(false);
    }));

    // --- UPLOAD HANDLER ---
    el.upload.addEventListener('change', (e) => {
        const files = Array.from(e.target.files);
        if (files.length === 0) return;
        state.files = files;
        el.debugLog.innerText = "";
        
        // Preview First File
        const firstFile = files[0];
        state.isGif = firstFile.type === 'image/gif';
        el.gifTag.style.display = state.isGif ? 'inline-block' : 'none';
        el.fileInfo.innerText = `Selected ${files.length} file(s) / å·²é€‰ ${files.length} ä¸ªæ–‡ä»¶`;
        
        const reader = new FileReader();
        reader.onload = (event) => {
            const dataUrl = event.target.result;
            // Always set img for static preview logic
            state.img = new Image();
            state.img.onload = () => {
                state.isLoaded = true;
                el.processBtn.disabled = false;
                updateCalculation(false);
            }
            state.img.src = dataUrl;

            // If GIF, we need to preload it into the hidden img tag for LibGif to find later
            if(state.isGif) {
                el.gifSource.src = dataUrl;
            }
        }
        reader.readAsDataURL(firstFile);
    });

    // --- MAIN PROCESSING (SERIAL / VISUAL SIMULATION) ---
    el.processBtn.addEventListener('click', async () => {
        if (!state.isLoaded || state.files.length === 0) return;
        el.processBtn.disabled = true;
        el.progSection.style.display = 'block';
        el.debugLog.innerText = "";
        
        const mainZip = new JSZip();
        
        try {
            for (let i = 0; i < state.files.length; i++) {
                const file = state.files[i];
                const isGif = file.type === 'image/gif';
                el.statusText.innerText = `Processing ${i+1}/${state.files.length}: ${file.name}`;
                el.progFill.style.width = ((i / state.files.length) * 100) + '%';
                
                // Read File
                const dataUrl = await readFileAsDataURL(file);
                
                // VISUAL UPDATE: Load this image into state.img so user sees it "working"
                await new Promise(r => {
                    state.img.src = dataUrl;
                    state.img.onload = r;
                });
                updateCalculation(false); // Update preview to current file
                await new Promise(r => setTimeout(r, 100)); // Small visual pause

                const targetZip = (state.files.length > 1) ? mainZip.folder(file.name.split('.')[0]) : mainZip;
                
                if (isGif) {
                    await processGifBatch(dataUrl, targetZip);
                } else {
                    await processStaticBatch(dataUrl, targetZip);
                }
            }
            
            el.statusText.innerText = "Zipping All / æ­£åœ¨æ‰“åŒ…...";
            el.progFill.style.width = "100%";
            mainZip.generateAsync({type:"blob"}).then((content) => {
                saveAs(content, "RabbitLin_Batch_Dataset.zip");
                el.processBtn.innerText = "âœ… Download Again / å†æ¬¡ä¸‹è½½";
                el.processBtn.disabled = false;
                el.statusText.innerText = "Done!";
            });
            
        } catch(err) {
            el.debugLog.innerText = "Error: " + err.message;
            el.processBtn.disabled = false;
        }
    });

    function readFileAsDataURL(file) {
        return new Promise(resolve => {
            const r = new FileReader();
            r.onload = e => resolve(e.target.result);
            r.readAsDataURL(file);
        });
    }

    // --- DRAWING HELPERS ---
    function getDrawParams(refImg) {
        const refW = state.img.width; 
        const refH = state.img.height;
        const curW = refImg.width;
        const curH = refImg.height;
        // Batch scaling logic: scale cellW based on current img size
        const ratioW = curW / refW || 1;
        const ratioH = curH / refH || 1;
        
        const resizeVal = el.resizeOpt.value;
        let targetW = state.cellW * ratioW, targetH = state.cellH * ratioH; 
        
        if (resizeVal !== 'original') {
            if (resizeVal.includes('x')) {
                const parts = resizeVal.split('x'); targetW = parseInt(parts[0]); targetH = parseInt(parts[1]);
            } else { const s = parseInt(resizeVal); targetW = s; targetH = s; }
        }
        
        targetW = Math.max(1, targetW); targetH = Math.max(1, targetH);
        
        return {
            rawW: state.cellW * ratioW, 
            rawH: state.cellH * ratioH, 
            targetW, targetH,
            scale: parseInt(el.contentScale.value) / 100,
            anchor: el.anchorPos.value, mode: el.resizeMode.value, srcX: 0, srcY: 0,
            ratioW, ratioH
        };
    }

    function drawFrameToCanvas(src, tgt, p) {
        const ctx = tgt.getContext('2d');
        ctx.fillStyle='#000'; ctx.fillRect(0,0,p.targetW,p.targetH);
        let dW=p.targetW, dH=p.targetH, dX=0, dY=0;
        
        if (p.mode === 'stretch') { 
            dW = p.targetW * p.scale; dH = p.targetH * p.scale; 
        } else {
            const sR = p.rawW/p.rawH, tR = p.targetW/p.targetH;
            let rScale = 1;
            if (p.mode === 'cover') rScale = (sR > tR) ? p.targetH/p.rawH : p.targetW/p.rawW;
            else rScale = (sR > tR) ? p.targetW/p.rawW : p.targetH/p.rawH;
            rScale *= p.scale; dW = p.rawW*rScale; dH = p.rawH*rScale;
        }
        
        if (p.anchor.includes('left')) dX=0; 
        else if (p.anchor.includes('right')) dX=p.targetW-dW; 
        else dX=(p.targetW-dW)/2;

        if (p.anchor.includes('top')) dY=0; 
        else if (p.anchor.includes('bottom')) dY=p.targetH-dH; 
        else dY=(p.targetH-dH)/2;

        if(p.rawW > 0 && p.rawH > 0) {
            try { ctx.drawImage(src, p.srcX, p.srcY, p.rawW, p.rawH, dX, dY, dW, dH); } 
            catch(e) { console.warn(e); }
        }
    }

    async function processStaticBatch(dataUrl, zipFolder) {
        return new Promise(resolve => {
            const img = new Image();
            img.onload = async () => {
                const p = getDrawParams(img);
                const cols = parseInt(el.cols.value), rows = parseInt(el.rows.value);
                const gapX = parseInt(el.gapX.value) * p.ratioW;
                const gapY = parseInt(el.gapY.value) * p.ratioH;

                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        const cvs = document.createElement('canvas');
                        cvs.width = p.targetW; cvs.height = p.targetH;
                        p.srcX = x * (p.rawW + gapX); p.srcY = y * (p.rawH + gapY);
                        drawFrameToCanvas(img, cvs, p);
                        zipFolder.file(`crop_${y}_${x}.png`, cvs.toDataURL().replace(/^data:image\/(png|jpg);base64,/, ""), {base64: true});
                    }
                }
                resolve();
            };
            img.src = dataUrl;
        });
    }

    // --- THE FIXED GIF LOGIC ---
    async function processGifBatch(dataUrl, zipFolder) {
        // 1. Force load image into the VISIBLE DOM element #gif-source
        // This is crucial for LibGif to detect size
        el.gifSource.src = dataUrl;
        await new Promise(r => el.gifSource.onload = r);

        return new Promise(resolve => {
            try {
                // 2. Initialize SuperGif on the visible element
                const superGif = new SuperGif({ gif: el.gifSource });
                superGif.load(async () => {
                    const len = superGif.get_length();
                    const canvas = superGif.get_canvas(); // The canvas libgif draws to
                    
                    const p = getDrawParams(canvas); 
                    const cols = parseInt(el.cols.value), rows = parseInt(el.rows.value);
                    const gapX = parseInt(el.gapX.value) * p.ratioW;
                    const gapY = parseInt(el.gapY.value) * p.ratioH;
                    
                    // Create Encoders
                    let encoders = [];
                    for(let i=0; i<rows*cols; i++) encoders.push(new GIF({workers:2, quality:10, workerScript:workerUrl, width:p.targetW, height:p.targetH}));

                    // Iterate Frames
                    for(let f=0; f<len; f++) {
                        superGif.move_to(f);
                        const frameCvs = superGif.get_canvas();
                        
                        // Give browser time to breathe (Prevent hanging)
                        if(f % 5 === 0) {
                            el.statusText.innerText = `GIF Frame ${f+1}/${len}`;
                            await new Promise(r => setTimeout(r, 0));
                        }

                        let idx=0;
                        for(let y=0; y<rows; y++) {
                            for(let x=0; x<cols; x++) {
                                p.srcX = x*(p.rawW+gapX); p.srcY = y*(p.rawH+gapY);
                                const tCvs = document.createElement('canvas'); tCvs.width=p.targetW; tCvs.height=p.targetH;
                                drawFrameToCanvas(frameCvs, tCvs, p);
                                encoders[idx].addFrame(tCvs, {delay:100, copy:true});
                                idx++;
                            }
                        }
                    }
                    
                    // Render (Serial Wait)
                    el.statusText.innerText = "Encoding GIF frames...";
                    const renderPromises = encoders.map((enc, i) => new Promise(rEnc => {
                        enc.on('finished', blob => {
                            const r=Math.floor(i/cols), c=i%cols;
                            zipFolder.file(`crop_${r}_${c}.gif`, blob);
                            rEnc();
                        });
                        enc.render();
                    }));
                    
                    await Promise.all(renderPromises);
                    resolve();
                });
            } catch(e) { 
                console.error("GIF Error", e);
                resolve(); // Skip broken GIF
            }
        });
    }

    // --- STANDARD UI FUNCTIONS ---
    function updateCalculation(fromDrag) {
        if (!state.isLoaded) return;
        const cols=parseInt(el.cols.value)||1, rows=parseInt(el.rows.value)||1;
        let gx=parseInt(el.gapX.value)||0, gy=parseInt(el.gapY.value)||0;
        if (!fromDrag) {
            state.cellW = Math.floor((state.img.width - (cols-1)*gx)/cols);
            state.cellH = Math.floor((state.img.height - (rows-1)*gy)/rows);
        } else {
            if(cols>1) gx = Math.floor((state.img.width - cols*state.cellW)/(cols-1));
            if(rows>1) gy = Math.floor((state.img.height - rows*state.cellH)/(rows-1));
            el.gapX.value=Math.max(0,gx); el.gapY.value=Math.max(0,gy);
        }
        drawGridPreview(cols, rows, gx, gy);
        updateSinglePreview(0, 0, gx, gy);
    }

    function drawGridPreview(cols, rows, gx, gy) {
        el.canvas.width = state.img.width; el.canvas.height = state.img.height;
        state.scaleFactor = el.canvas.clientWidth / state.img.width;
        ctx.drawImage(state.img, 0, 0);
        const lw = Math.max(3, state.img.width/300); ctx.lineWidth = lw;
        for (let y=0; y<rows; y++) {
            for (let x=0; x<cols; x++) {
                const pX = x*(state.cellW+gx), pY = y*(state.cellH+gy);
                ctx.strokeStyle = '#ff0000'; ctx.strokeRect(pX, pY, state.cellW, state.cellH);
                if(x===0 && y===0) { ctx.fillStyle='#ffcc00'; const h=lw*4; ctx.fillRect(pX+state.cellW-h, pY+state.cellH-h, h, h); }
            }
        }
    }

    function updateSinglePreview(x, y, gx, gy) {
        const p = getDrawParams(state.img);
        // Reset scale for single preview context
        p.rawW = state.cellW; p.rawH = state.cellH; 
        p.srcX = x*(state.cellW+gx); p.srcY = y*(state.cellH+gy);
        p.gapX = 0; p.gapY = 0; 

        el.finalRes.innerText = `${p.targetW} x ${p.targetH}`;
        
        // If GIF mode, try to get frame 0 from SuperGif if loaded, else img
        let source = state.img;
        // Only try to use gif canvas if we are in single mode view and it's loaded
        if(state.isGif && state.superGif) {
             // We can't easily get frame 0 without playing, just use static img for preview speed
        }

        const cvs = document.createElement('canvas'); cvs.width=p.targetW; cvs.height=p.targetH;
        drawFrameToCanvas(source, cvs, p);
        el.singlePreview.src = cvs.toDataURL();
    }

    function getPos(e) { const r = el.canvas.getBoundingClientRect(); return { x: (e.clientX - r.left)/state.scaleFactor, y: (e.clientY - r.top)/state.scaleFactor }; }
    el.canvas.addEventListener('mousedown', (e) => { if(state.isLoaded) { const p=getPos(e), z=Math.max(40, state.img.width/30); if(Math.abs(p.x-state.cellW)<z && Math.abs(p.y-state.cellH)<z) { state.isDragging=true; state.dragStartPos=p; state.initialCellSize={w:state.cellW,h:state.cellH}; el.canvas.style.cursor='nwse-resize'; } } });
    el.canvas.addEventListener('mousemove', (e) => { if(state.isDragging) { const p=getPos(e), cols=parseInt(el.cols.value)||1, rows=parseInt(el.rows.value)||1; let nw=state.initialCellSize.w+(p.x-state.dragStartPos.x), nh=state.initialCellSize.h+(p.y-state.dragStartPos.y); const rv=el.aspectRatio.value; if(rv!=='free'){ nh=Math.round(nw/parseFloat(rv)); } state.cellW=Math.floor(Math.max(50,Math.min(nw,state.img.width/cols))); state.cellH=Math.floor(Math.max(50,Math.min(nh,state.img.height/rows))); updateCalculation(true); } });
    document.addEventListener('mouseup', () => { state.isDragging=false; el.canvas.style.cursor='crosshair'; });
</script>
</body>
</html>
